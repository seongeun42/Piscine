/* La Piscine Shell01 */


1. ex01
 1) 문제 조건 : 환경변수 $FT_USER가 소속되어 있는 그룹의 목록을 그룹명으로 표시하되, 공백 없이 쉼표로 분리되어 나열, 줄바꿈 없음
 2) 환경 변수 $FT_USER는 현재 로그인한 유저를 의미함
 3) 유저는 여러 그룹에 소속될 수 있는데, 이때 그룹은 그룹ID와 그룹명으로 표현될 수 있음
 4) 유저가 속한 그룹명을 보기 위해서는 groups 명령어를 사용하거나, id 명령어에 옵션을 사용하는 방법이 있음
 5) id 명령어 옵션 : -G는 유저가 속한 그룹ID를 출력, -n은 ID 대신 이름으로 출력
 6) 기본적으로 나열될 때 속한 그룹이 여러 개일 경우 공백으로 그룹이 구분되는데, tr 명령어나 sed 명령어를 통해 공백을 쉼표로 치환하면 됨
 7-1) id -Gn $FT_USER | tr ' ' ',' | tr -d '\n'
 7-2) groups $FT_USER | tr ' ' ',' | tr -d '\n'


2. ex02
 1) 문제 조건 : 현재와 하위 디렉터리에서 .sh 파일을 찾되, 확장자를 제외한 이름만 출력
 2) 파일을 찾기 위해 find 명령어를 사용하고, 범위 지정을 위해 . 사용, 파일만 출력을 위해 -type f 옵션 사용
 3) -name '*.sh'를 통해 파일을 탐색
 4) 확장자 제거한 파일명만 출력하기 위해, 경로 제외한 파일명만 출력해주는 basename 명령어 사용
 5) 확장자를 제거하기 위해 sed 명령어를 사용해 확장자 부분을 공백으로 치환
 -> find . -type f -name '*.sh' -exec basename {} \; | sed 's/\.sh//'
 -> find . -type f -name '*.sh' -exec basename {} .sh \;


3. ex03
 1) 문제 조건 : 현재와 하위 디렉터리에 있는 모든 일반 파일과 디렉토리 개수 세기, 시작 디렉토리 포함
 2) 현재와 하위 디렉터리에 있는 걸 전부 찾기 위해 find . 을 사용
 3) 개수를 세기 위해 단어수를 세어주는 명령어인 wc를 사용했는데, 이때 라인수를 출력하는 -l 옵션을 사용
 4) 출력될 때 wc 출력 형식에 맞춰 공백이 포함되므로, tr을 사용해 공백을 제거
 -> find . | wc -l | tr -d ' '


4. ex04
 1) 문제 조건 : 컴퓨터의 MAC 주소를 표시하되, 각 주소 끝에는 줄바꿈
 2) MAC 주소를 알기 위해, ifconfig -a 명령어를 통해 네트워크 정보를 출력
 3) 네트워크 정보 중에서도 MAC 주소만 추출하기 위해 grep 명령어로 'ether '가 있는 라인만 뽑아냄
 4) 출력 형식을 정리하기 위해 awk 명령어로 MAC 주소만 뽑아냄	// 필드값 출력 방식으로 사용
 -> ifconfig -a | grep 'ether ' | awk '{print $2}'
 -> ifconfig -a | grep -w 'ether' | awk '{print $2}'


5. ex05
 1) 문제 조건 : 파일명에 특수문자가 포함되고 2바이트의 '42'만 내용으로 가지는 파일 만들기
 2) 특수문자를 파일명으로 사용하기 위해 이스케이프 문자(\)를 사용해 특수문자를 일반문자처럼 만듦
 3) 2바이트의 '42'을 하기 위해 개행문자를 자동으로 넣는 에디터를 사용하지 않고 cat으로 파일에 내용을 넣음
 -> touch "\"\\?\$*'MaRViN'*\&?\\\""		// $는 환경변수가 아니게 하려고 넣음
 -> cat > *Ma* 사용 후, 42 입력한 다음 ctrl+d 두번 


6. ex06
 1) 문제 조건 : ls -l 명령어를 홀수행만 출력
 2) 특정 조건에 맞는 라인만 출력할 수 있어야 함 -> sed, awk 사용
 3) sed -n 'p;n'  OR  sed 'n;d;p'  // p는 출력, d는 삭제, n은 다음 행에서 처리, -n은 자동출력 무시
 4) awk 'NR%2==1' // NR은 행넘버를 알려주는 명령어, 행이 홀수행일 때만 출력
 -> ls -l | awk 'NR%2==1'


7. ex07
 1) 문제 조건 : 주석 삭제, 두번째 행부터 하나씩 건너서(짝수행), login만 추출하되 역으로 반전, 추출한 login을 알파벳 역순으로 정렬, FT_LINE1~FT_LINE2의 값만 출력, 콤마로 구분, 온점으로 끝남
 2) 주석을 삭제하기 위해 sed로 #으로 시작하는 행 삭제	// sed '/키워드/d' : 키워드를 포함하는 행 삭제 
 3) 짝수행을 뽑기 위해 awk 'NR%2==0' 사용
 4) login 추출을 위해 awk -F ':' '{print $1}' 사용
 5) 추출한 login을 역순으로 하기 위해 rev 명령어 사용
 6) 알파벳 역순을 정렬하기 위해 sort -r 명령어 사용
 7) 조건 범위의 값만 출력하기 위해 sed -n "i,jp" 사용	// i~j행만 출력
 8) 콤마로 구분하기 위해 줄바꿈을 tr 명령어를 사용해서 ,로 치환하고, ', '으로 하기 위해 sed를 사용해 ','를 ', '로 치환
 9) 마지막에 온점을 찍기 위해 sed 명령어로 제일 끝의 ,를 찾아 .으로 치환
 10) tr로 줄바꿈 삭제
 -> cat /etc/passwd | sed '/#/d' | awk 'NR%2==0' | awk -F ':' '{print $1}' | rev | sort -r | sed -n "${FT_LINE1},${FT_LINE2}p" | tr '\n' ',' | sed 's/,/, /g' | sed 's/, $/./g' | tr -d '\n'


8. ex08
 1) 문제 조건 : 진수 변환 계산 문제. 각 문자를 해당하는 숫자로 치환한 후 계산하고, 다시 대응되는 문자로 치환해야 함
 3) 우선 '\"?!를 01234로 치환하기 위해, sed와 tr 명령어를 사용함	// '를 치환하기 위해 sed 사용
 4) mrdoc을 01234로 치환하기 위해, tr 명령어를 사용함
 5) 치환한 문자를 더한 결과를 계산하기 위한 인자값으로 넣어주기 위해 xargs 명령어를 사용함
 6) 계산하기 위해서 bc 명령어를 사용하는데, 그 전에 수식을 넣어줌
 7) 수식은 'obase=13; abase=5;' | bc 인데, 앞의 결과값( X + Y )이 5진수로 들어오니까 13진수로 바꾸라는 뜻
 8) 13진수로 바뀐 결과를 문자로 바꿔주기 위해, tr을 사용

 - 실행 전에 전역 변수 넣어주기
 -> export FT_NBR1="\\\'?\"\\\"'\\"	// '하나 안 넣은 이유는 "'" 상태라 안 넣어도 출력돼서
 -> export FT_NBR2=rcrdmddd
 -> echo $FT_NBR1 + $FT_NBR2 | sed "s/\'/0/g" | tr '\\\"\?\!' 1234 | tr 'mrdoc' 01234 | xargs echo 'obase=13; ibase=5;' | bc | tr 0123456789ABC 'gtaio luSnemf'
